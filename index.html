<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>

  <!-- PWA essentials -->
  <meta name="theme-color" content="#111111" />
  <link rel="manifest" href="/manifest.webmanifest" />
  <link rel="icon" href="/icons/icon-192.png" />

  <title>APP Tracker</title>

  <style>
    :root{--bg:#0b0f14;--card:#121826;--text:#e6eefb;--muted:#9fb0c5;--accent:#4aa3ff;--bad:#ff5a5f;--good:#42d392;}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text);}
    .wrap{max-width:1100px;margin:0 auto;padding:16px 14px 140px;}
    h1{font-size:18px;margin:0 0 10px;}
    .row{display:flex;gap:12px;flex-wrap:wrap;}
    .card{background:var(--card);border:1px solid rgba(255,255,255,.06);border-radius:14px;padding:12px;}
    .grow{flex:1 1 520px;}
    .small{flex:1 1 320px;}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px;}
    select,button,input{font-size:14px;border-radius:12px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.03);color:var(--text);padding:10px 12px;}
    select,input{width:100%;}
    .grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;}
    .btn{width:100%;padding:14px 12px;font-weight:800;}
    .btn.good{border-color:rgba(66,211,146,.45);}
    .btn.neutral{border-color:rgba(159,176,197,.35);}
    .btn.primary{border-color:rgba(74,163,255,.55);}
    .btn.ok{border-color:rgba(66,211,146,.55);}
    .btn.danger{border-color:rgba(255,90,95,.55);}
    .btn:disabled{opacity:.45;}
    .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.03);}
    .k{color:var(--muted);font-size:12px;}
    .v{font-weight:900;}
    .big{font-size:22px;font-weight:950;}
    .muted{color:var(--muted);}
    .sep{height:1px;background:rgba(255,255,255,.08);margin:10px 0;}
    .actions{display:flex;gap:10px;flex-wrap:wrap;}
    .note{font-size:12px;color:var(--muted);margin-top:8px;line-height:1.35;}
    .toggleRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .toggle{display:flex;gap:8px;align-items:center;}
    input[type="checkbox"]{width:18px;height:18px;}
    .log{max-height:360px;overflow:auto;border-radius:12px;border:1px solid rgba(255,255,255,.08);}
    table{width:100%;border-collapse:collapse;font-size:12px;}
    th,td{padding:8px 10px;border-bottom:1px solid rgba(255,255,255,.06);text-align:left;white-space:nowrap;}
    th{position:sticky;top:0;background:#0f1624;z-index:1;}
    .right{text-align:right;}
    .selectedBox{display:flex;align-items:center;justify-content:space-between;gap:10px;border:1px dashed rgba(255,255,255,.18);border-radius:14px;padding:10px 12px;}
    .selectedTag{font-weight:900;}
    .mini{font-size:12px;color:var(--muted);}
    .infoBtn{display:inline-flex;align-items:center;justify-content:center;width:22px;height:22px;border-radius:999px;border:1px solid rgba(255,255,255,.15);background:rgba(255,255,255,.04);color:var(--text);font-weight:900;cursor:pointer;user-select:none;}
    .footerbar{position:fixed;left:0;right:0;bottom:0;background:rgba(11,15,20,.92);border-top:1px solid rgba(255,255,255,.08);padding:10px 14px;}
    .footerbar .wrap{padding:0;}
    /* modal */
    .backdrop{position:fixed;inset:0;background:rgba(0,0,0,.58);display:none;align-items:center;justify-content:center;padding:18px;z-index:9999;}
    .modal{width:min(560px,100%);background:#0f1624;border:1px solid rgba(255,255,255,.12);border-radius:16px;padding:14px;}
    .modal h2{margin:0 0 8px;font-size:16px;}
    .modal .content{font-size:14px;line-height:1.45;color:var(--text);}
    .modal .content .muted{color:var(--muted);}
    .modal .btnrow{display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap;margin-top:12px;}
    .modal .btnrow button{min-width:140px;}
  </style>
</head>

<body>
<div class="wrap">
  <h1>APP Tracker — staged input + auto decisions + CSV + bankroll</h1>

  <div class="row">
    <div class="card small">
      <label>Game Type</label>
      <select id="gameType">
        <option value="roulette">American Roulette (R/B + Green)</option>
        <option value="baccarat">Vegas Baccarat (Player/Banker + Tie)</option>
      </select>

      <div class="sep"></div>

      <label>Series</label>
      <select id="series">
        <option value="A">Series A</option>
        <option value="B">Series B</option>
      </select>

      <div class="sep"></div>

      <label>Start Mode (used when Carry Mode is OFF)</label>
      <select id="startMode">
        <option value="SAME">SAME</option>
        <option value="OPP">OPPOSITE</option>
      </select>

      <div class="sep"></div>

      <div class="toggleRow">
        <div class="toggle">
          <input type="checkbox" id="autoSeries"/>
          <label style="margin:0;display:flex;gap:8px;align-items:center;">
            Auto Series
            <span class="infoBtn" data-tip="autoSeries">i</span>
          </label>
        </div>
        <div class="toggle">
          <input type="checkbox" id="carryMode"/>
          <label style="margin:0;display:flex;gap:8px;align-items:center;">
            Carry Mode
            <span class="infoBtn" data-tip="carryMode">i</span>
          </label>
        </div>
      </div>

      <div class="sep"></div>

      <label style="display:flex;justify-content:space-between;align-items:center;">
        <span>Bankroll Manager</span>
        <span class="infoBtn" data-tip="bankroll">i</span>
      </label>
      <div class="toggleRow">
        <div class="toggle">
          <input type="checkbox" id="bankrollOn"/>
          <label style="margin:0;">Enable</label>
        </div>
      </div>
      <div class="row" style="margin-top:8px;">
        <div style="flex:1 1 160px;">
          <label>Starting Bankroll</label>
          <input id="bankrollStart" inputmode="decimal" placeholder="e.g., 300"/>
        </div>
        <div style="flex:1 1 120px;display:flex;flex-direction:column;justify-content:end;">
          <button class="btn primary" id="applyBankrollBtn" style="padding:10px 12px;">Apply</button>
        </div>
      </div>
      <div class="note">
        Current Bankroll: <b id="bankrollCurrent">—</b><br/>
        Session Net: <b id="bankrollNet">—</b>
      </div>

      <div class="sep"></div>

      <button class="btn primary" id="newGameBtn">New Game (observe 1 true outcome first)</button>
      <button class="btn ok" id="newEveningBtn" style="margin-top:10px;">New Evening (clear log)</button>
    </div>

    <div class="card grow">
      <div class="row" style="align-items:center;">
        <div class="pill"><span class="k">NEXT SIDE</span> <span class="v big" id="nextSide">—</span></div>
        <div class="pill"><span class="k">NEXT BET</span> <span class="v big" id="nextBet">—</span></div>
        <div class="pill"><span class="k">MODE</span> <span class="v" id="mode">—</span></div>
        <div class="pill"><span class="k">MODE LOSSES</span> <span class="v" id="modeLosses">—</span></div>
        <div class="pill"><span class="k">SERIES</span> <span class="v" id="seriesShow">—</span></div>
        <div class="pill"><span class="k">GAME PnL</span> <span class="v big" id="gamePnL">0</span></div>
      </div>

      <div class="sep"></div>

      <div class="row" style="gap:10px;">
        <div class="pill"><span class="k">STATE</span> <span class="v" id="state">NORMAL</span></div>
        <div class="pill"><span class="k">CONSEC WINS (SAME)</span> <span class="v" id="cw">0</span></div>
        <div class="pill"><span class="k">LADDER BET</span> <span class="v" id="ladderBet">—</span></div>
        <div class="pill"><span class="k">SPLIT LEDGER</span> <span class="v" id="ledger">—</span></div>
        <div class="pill"><span class="k">SPLIT PHASE</span> <span class="v" id="splitPhase">—</span></div>
        <div class="pill"><span class="k">NEXT SPLIT BET</span> <span class="v" id="nextSplitBet">—</span></div>
      </div>

      <div class="sep"></div>

      <div class="selectedBox">
        <div>
          <div class="mini">Selected Outcome (not submitted)</div>
          <div class="selectedTag" id="selectedOutcome">—</div>
        </div>
        <div class="actions">
          <button class="btn" id="clearSelBtn" style="padding:10px 12px;">Clear</button>
          <button class="btn primary" id="submitSelBtn" style="padding:10px 12px;">Submit</button>
          <button class="btn ok" id="undoBtn" style="padding:10px 12px;">Undo</button>
        </div>
      </div>

      <div class="sep"></div>

      <div class="grid" id="buttons"></div>
      <div class="note" id="hint"></div>
    </div>
  </div>

  <div class="row" style="margin-top:12px;">
    <div class="card grow">
      <div class="row" style="align-items:center; justify-content:space-between;">
        <div>
          <div class="muted" style="font-size:12px;">Session Log</div>
          <div style="font-weight:900;">Rows: <span id="logCount">0</span> &nbsp; | &nbsp; Game#: <span id="gameNo">0</span></div>
        </div>
        <div class="actions">
          <button class="btn primary" id="exportCsvBtn" style="padding:10px 12px;">Export CSV</button>
          <button class="btn danger" id="resetSessionBtn" style="padding:10px 12px;">Reset Session</button>
        </div>
      </div>
      <div class="sep"></div>
      <div class="log">
        <table>
          <thead>
          <tr>
            <th>#</th><th>Game#</th><th>Series</th><th>Type</th>
            <th>Outcome</th><th>Pick</th><th class="right">Bet</th>
            <th>Result</th><th class="right">ΔPnL</th><th class="right">GamePnL</th>
            <th>Mode</th><th>State</th><th class="right">Ledger</th><th>Note</th>
          </tr>
          </thead>
          <tbody id="logBody"></tbody>
        </table>
      </div>
    </div>
  </div>
</div>

<div class="footerbar">
  <div class="wrap">
    <div class="note">
      Rules baked in: NORMAL capped (A:30, B:60). Split triggers only from NORMAL cap-loss (roulette: cap+green counts). Split freezes ladder. Tie during split = push (repeat same split bet). TP ends immediately in SPLIT; TP ends at streak loss in STREAK.
    </div>
  </div>
</div>

<!-- Tooltip Modal -->
<div class="backdrop" id="tipBackdrop" role="dialog" aria-modal="true">
  <div class="modal">
    <h2 id="tipTitle">Info</h2>
    <div class="content" id="tipBody"></div>
    <div class="btnrow">
      <button class="btn primary" id="tipCloseBtn">Close</button>
    </div>
  </div>
</div>

<!-- End Game Modal -->
<div class="backdrop" id="endBackdrop" role="dialog" aria-modal="true">
  <div class="modal">
    <h2 id="endTitle">Game Ended</h2>
    <div class="content" id="endBody"></div>
    <div class="btnrow">
      <button class="btn primary" id="nextGameFromModalBtn">Start Next Game</button>
      <button class="btn" id="closeEndBtn">Close</button>
    </div>
  </div>
</div>

<!-- (Optional) Keep app.js if you want a separate JS file later; harmless now -->
<script src="/app.js"></script>

<script>
(() => {
  const STORAGE_KEY = "app_tracker_v3";

  const BANKER_COMMISSION = 0.05;
  const ANCHOR_STREAK_A = 18;
  const ANCHOR_SPLITCLEAR_A = 15;

  const tips = {
    autoSeries: {
      title: "Auto Series",
      body: `
        <div><b>ON:</b> If a Series A game ends at SL, the <b>next game</b> becomes <b>one Series B game only</b>, then returns to Series A.</div>
        <div class="muted" style="margin-top:8px;">Manual series selection still works if you turn this OFF.</div>`
    },
    carryMode: {
      title: "Carry Mode",
      body: `
        <div><b>OFF (default):</b> Every new game starts in your selected Start Mode (SAME/OPP).</div>
        <div style="margin-top:8px;"><b>ON:</b> The next game starts in the same mode you ended the previous game in.</div>`
    },
    bankroll: {
      title: "Bankroll Manager",
      body: `
        <div>Enter Starting Bankroll and press <b>Apply</b>.</div>
        <div style="margin-top:8px;">When a game ends (TP or SL), bankroll updates by that game’s final PnL.</div>
        <div class="muted" style="margin-top:8px;">Bankroll values are not included in CSV export (by design).</div>`
    }
  };

  function seriesParams(series){
    if(series === "B"){
      return { base:10, tp:80, sl:-200, incL:6, decW:4, min:10, cap:60,
        anchorStreak:ANCHOR_STREAK_A*2, anchorSplit:ANCHOR_SPLITCLEAR_A*2, maxSplitBet:180, splitLedger:120 };
    }
    return { base:5, tp:40, sl:-100, incL:3, decW:2, min:5, cap:30,
      anchorStreak:ANCHOR_STREAK_A, anchorSplit:ANCHOR_SPLITCLEAR_A, maxSplitBet:90, splitLedger:60 };
  }

  const deepCopy = (o)=>JSON.parse(JSON.stringify(o));
  const $ = (id)=>document.getElementById(id);

  const defaultState = () => ({
    sessionId: Date.now(),
    log: [],
    undoStack: [],

    // settings
    gameType: "roulette",
    series: "A",
    startMode: "SAME",
    autoSeries: true,
    carryMode: false,
    pendingOneB: false,

    // bankroll
    bankrollOn: false,
    bankrollStart: null,
    bankrollCurrent: null,

    // per-game
    inGame: false,
    observed: false,
    gameNo: 0,
    lastTrue: null,
    mode: "SAME",
    modeLosses: 0,
    consecWinsSame: 0,

    phase: "NORMAL",
    ladderBet: 5,
    streakBet: null,
    tpHitDuringStreak: false,

    // split
    ledger: 0,
    splitPhase: null,
    nextSplitBet: null,
    half1: null,
    half2: null,

    gamePnL: 0,

    // staged input
    pendingOutcome: null,

    // end modal state
    endModalOpen: false,
    lastEndedBy: null,
    lastEndedPnL: null
  });

  let S = load() || defaultState();

  function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(S)); }
  function load(){ try { return JSON.parse(localStorage.getItem(STORAGE_KEY)); } catch(e){ return null; } }

  function pushUndo(){
    S.undoStack.push(deepCopy(S));
    if(S.undoStack.length > 300) S.undoStack.shift();
  }
  function undo(){
    if(!S.undoStack.length) return;
    S = S.undoStack.pop();
    save(); render();
  }

  function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
  function currentParams(){ return seriesParams(S.series); }

  function isNeutral(outcome){
    return (S.gameType === "roulette") ? (outcome === "G") : (outcome === "T");
  }
  function isTrue(outcome){
    return (S.gameType === "roulette")
      ? (outcome === "R" || outcome === "B")
      : (outcome === "P" || outcome === "B");
  }
  function oppositeOf(out){
    return (S.gameType === "roulette") ? (out === "R" ? "B" : "R") : (out === "P" ? "B" : "P");
  }
  function computePick(){
    if(!S.lastTrue) return null;
    return (S.mode === "SAME") ? S.lastTrue : oppositeOf(S.lastTrue);
  }

  function formatOutcome(x){
    if(!x) return "—";
    if(S.gameType === "roulette"){
      return x === "R" ? "RED" : x === "B" ? "BLACK" : "GREEN";
    }
    return x === "P" ? "PLAYER" : x === "B" ? "BANKER" : "TIE";
  }

  function settleProfit(bet, won, pick){
    if(S.gameType === "roulette") return won ? bet : -bet;
    if(!won) return -bet;
    if(pick === "B") return bet * (1.0 - 0.05);
    return bet;
  }

  function logRow({ outcome, pick, bet, result, delta, note }){
    const idx = S.log.length + 1;
    S.log.push({
      idx,
      ts: new Date().toISOString(),
      gameNo: S.gameNo,
      series: S.series,
      gameType: S.gameType,
      outcome, pick, bet, result, delta,
      gamePnL: S.gamePnL,
      mode: S.mode,
      modeLosses: S.modeLosses,
      phase: S.phase,
      ledger: S.ledger,
      splitPhase: S.splitPhase,
      nextSplitBet: S.nextSplitBet,
      ladderBet: S.ladderBet,
      consecWinsSame: S.consecWinsSame,
      note: note || ""
    });
  }

  function showTip(which){
    $("tipTitle").textContent = tips[which]?.title || "Info";
    $("tipBody").innerHTML = tips[which]?.body || "";
    $("tipBackdrop").style.display = "flex";
  }
  function closeTip(){ $("tipBackdrop").style.display = "none"; }

  function showEndModal(endedBy, finalPnL){
    S.endModalOpen = true;
    S.lastEndedBy = endedBy;
    S.lastEndedPnL = finalPnL;

    const p = currentParams();
    let bankrollLine = `<div class="muted" style="margin-top:8px;">Bankroll manager is OFF.</div>`;
    if(S.bankrollOn && typeof S.bankrollCurrent === "number"){
      bankrollLine = `<div style="margin-top:8px;"><b>Bankroll:</b> ${S.bankrollCurrent.toFixed(2)} <span class="muted">(session net ${(S.bankrollCurrent - (S.bankrollStart||0)).toFixed(2)})</span></div>`;
    }

    $("endTitle").textContent = `GAME ENDED — ${endedBy}`;
    $("endBody").innerHTML = `
      <div><b>Series:</b> ${S.series} &nbsp; <span class="muted">(TP/SL ${p.tp} / ${p.sl})</span></div>
      <div style="margin-top:8px;"><b>Final Game P&L:</b> ${finalPnL.toFixed(2)}</div>
      ${bankrollLine}
    `;
    $("endBackdrop").style.display = "flex";
    save(); render();
  }
  function closeEndModal(){
    S.endModalOpen = false;
    $("endBackdrop").style.display = "none";
    save(); render();
  }

  function maybeAutoSeriesAfterGame(endedBy){
    if(!S.autoSeries) return;
    if(S.series === "A" && endedBy === "SL"){
      S.pendingOneB = true;
    } else if(S.series === "B"){
      S.series = "A";
      S.pendingOneB = false;
    }
  }

  function startNewGame(){
    pushUndo();

    if(S.autoSeries && S.pendingOneB) S.series = "B";
    const p = currentParams();

    S.inGame = true;
    S.observed = false;
    S.gameNo += 1;

    S.lastTrue = null;

    if(S.carryMode && S.gameNo > 1){
      S.mode = S.mode || S.startMode;
    } else {
      S.mode = S.startMode;
    }
    S.modeLosses = 0;
    S.consecWinsSame = 0;

    S.phase = "NORMAL";
    S.ladderBet = p.min;
    S.streakBet = null;
    S.tpHitDuringStreak = false;

    S.ledger = 0;
    S.splitPhase = null;
    S.nextSplitBet = null;
    S.half1 = null;
    S.half2 = null;

    S.gamePnL = 0;
    S.pendingOutcome = null;

    save(); render();
  }

  function endGame(endedBy){
    if(S.bankrollOn && typeof S.bankrollCurrent === "number"){
      S.bankrollCurrent = +(S.bankrollCurrent + S.gamePnL).toFixed(2);
    }
    S.inGame = false;
    S.observed = false;
    maybeAutoSeriesAfterGame(endedBy);
    S.pendingOutcome = null;
    showEndModal(endedBy, S.gamePnL);
  }

  function applyModeWin(){ S.modeLosses = 0; }
  function applyModeLoss(neutralLoss){
    if(neutralLoss) return;
    S.modeLosses += 1;
    if(S.mode === "SAME"){
      if(S.modeLosses >= 2){ S.mode = "OPP"; S.modeLosses = 0; S.consecWinsSame = 0; }
    } else {
      if(S.modeLosses >= 1){ S.mode = "SAME"; S.modeLosses = 0; S.consecWinsSame = 0; }
    }
  }

  function enterStreak(){
    const p = currentParams();
    S.phase = "STREAK";
    S.streakBet = S.ladderBet + p.base;
    S.tpHitDuringStreak = false;
    S.consecWinsSame = 0;
  }
  function exitStreakAfterLoss(){
    const p = currentParams();
    S.phase = "NORMAL";
    S.streakBet = null;
    S.ladderBet = p.anchorStreak;
    S.consecWinsSame = 0;
  }

  function enterSplit(){
    const p = currentParams();
    S.phase = "SPLIT";
    S.ledger = p.splitLedger;
    S.splitPhase = "PROBE";
    S.nextSplitBet = p.min;
    S.half1 = null; S.half2 = null;
    S.consecWinsSame = 0;
    S.streakBet = null;
    S.tpHitDuringStreak = false;
  }
  function computeSplitHalves(){
    const p = currentParams();
    let h1 = Math.ceil(S.ledger / 2);
    let h2 = S.ledger - h1;
    if(h1 > p.maxSplitBet){ h1 = p.maxSplitBet; h2 = S.ledger - h1; }
    S.half1 = h1; S.half2 = h2;
  }
  function clearSplit(){
    const p = currentParams();
    S.phase = "NORMAL";
    S.ledger = 0;
    S.splitPhase = null;
    S.nextSplitBet = null;
    S.half1 = null; S.half2 = null;
    S.ladderBet = p.anchorSplit;
    S.consecWinsSame = 0;
    S.streakBet = null;
    S.tpHitDuringStreak = false;
  }

  function checkEndOutsideStreak(){
    const p = currentParams();
    if(S.gamePnL >= p.tp){ endGame("TP"); return true; }
    if(S.gamePnL <= p.sl){ endGame("SL"); return true; }
    return false;
  }

  function outcomeButtons(){
    return (S.gameType === "roulette")
      ? [{k:"R",t:"RED",c:"good"},{k:"B",t:"BLACK",c:"good"},{k:"G",t:"GREEN (0/00)",c:"neutral"}]
      : [{k:"P",t:"PLAYER",c:"good"},{k:"B",t:"BANKER",c:"good"},{k:"T",t:"TIE",c:"neutral"}];
  }

  function renderButtons(){
    const root = $("buttons");
    root.innerHTML = "";
    for(const b of outcomeButtons()){
      const el = document.createElement("button");
      el.className = `btn ${b.c}`;
      el.textContent = b.t;
      el.onclick = () => { S.pendingOutcome = b.k; save(); render(); };
      root.appendChild(el);
    }
  }

  function observeOrBet(outcome){
    if(!S.inGame) startNewGame();

    if(!S.observed){
      if(isTrue(outcome)){
        S.lastTrue = outcome;
        S.observed = true;
        logRow({ outcome: formatOutcome(outcome), pick:"—", bet:0, result:"OBS", delta:0, note:"Observation set lastTrue" });
      } else {
        logRow({ outcome: formatOutcome(outcome), pick:"—", bet:0, result:"OBS", delta:0, note:"Observation (neutral)" });
      }
      S.pendingOutcome = null;
      save(); render();
      return true;
    }
    return false;
  }

  function submitPending(){
    if(!S.pendingOutcome) return;
    pushUndo();
    const outcome = S.pendingOutcome;
    if(S.endModalOpen){ return; }
    if(observeOrBet(outcome)) return;

    const p = currentParams();
    const pick = computePick();
    const neutral = isNeutral(outcome);

    let bet = 0;
    if(S.phase === "NORMAL") bet = S.ladderBet;
    else if(S.phase === "STREAK") bet = Math.round(S.streakBet);
    else if(S.phase === "SPLIT") bet = Math.round(S.nextSplitBet || p.min);

    let result = "L";
    let won = false;

    if(S.gameType === "baccarat" && outcome === "T"){
      result = "P";
      bet = 0;
    } else if(S.gameType === "roulette" && outcome === "G"){
      result = "L";
      won = false;
    } else {
      won = (outcome === pick);
      result = won ? "W" : "L";
    }

    let delta = 0;
    if(result !== "P" && bet > 0){
      delta = settleProfit(bet, won, pick);
      S.gamePnL = +(S.gamePnL + delta).toFixed(2);
    }

    logRow({ outcome: formatOutcome(outcome), pick: pick ? formatOutcome(pick) : "—", bet, result, delta: +delta.toFixed(2), note: "" });

    if(isTrue(outcome)) S.lastTrue = outcome;
    S.pendingOutcome = null;

    if(result === "P"){ save(); render(); return; }

    if(S.phase === "NORMAL"){
      if(won){
        applyModeWin();
        if(S.mode === "SAME") S.consecWinsSame += 1;
        else S.consecWinsSame = 0;
        S.ladderBet = clamp(S.ladderBet - p.decW, p.min, p.cap);
        if(S.mode === "SAME" && S.consecWinsSame >= 2){ enterStreak(); }
      } else {
        S.consecWinsSame = 0;
        S.ladderBet = clamp(S.ladderBet + p.incL, p.min, p.cap);
        applyModeLoss(neutral);

        const atCap = (bet === p.cap);
        if(atCap){
          if(!neutral){ enterSplit(); }
          else if(S.gameType === "roulette" && outcome === "G"){ enterSplit(); }
        }
      }
      if(checkEndOutsideStreak()) return;
    }
    else if(S.phase === "STREAK"){
      if(won){
        applyModeWin();
        S.streakBet = S.streakBet + p.base;
        if(S.gamePnL >= p.tp) S.tpHitDuringStreak = true;
      } else {
        applyModeLoss(neutral);
        const tpReached = S.tpHitDuringStreak || (S.gamePnL >= p.tp);
        exitStreakAfterLoss();
        if(tpReached){ endGame("TP"); return; }
      }
      if(S.gamePnL <= p.sl){ endGame("SL"); return; }
    }
    else if(S.phase === "SPLIT"){
      if(S.splitPhase === "PROBE"){
        if(won){
          applyModeWin();
          S.ledger = Math.max(0, +(S.ledger - p.min).toFixed(2));
          computeSplitHalves();
          S.splitPhase = "PAY1";
          S.nextSplitBet = S.half1;
        } else {
          S.ledger = +(S.ledger + p.min).toFixed(2);
          applyModeLoss(neutral);
          S.nextSplitBet = p.min;
        }
      }
      else if(S.splitPhase === "PAY1"){
        if(won){
          applyModeWin();
          S.ledger = Math.max(0, +(S.ledger - S.half1).toFixed(2));
          S.splitPhase = "PAY2";
          S.nextSplitBet = Math.max(0, S.half2);
        } else {
          S.ledger = +(S.ledger + S.half1).toFixed(2);
          applyModeLoss(neutral);
          S.splitPhase = "PROBE";
          S.nextSplitBet = p.min;
        }
      }
      else if(S.splitPhase === "PAY2"){
        if(won){
          applyModeWin();
          S.ledger = Math.max(0, +(S.ledger - S.half2).toFixed(2));
          if(S.ledger <= 0){ clearSplit(); }
          else { S.splitPhase = "PROBE"; S.nextSplitBet = p.min; }
        } else {
          S.ledger = +(S.ledger + S.half2).toFixed(2);
          applyModeLoss(neutral);
          S.splitPhase = "PROBE";
          S.nextSplitBet = p.min;
        }
      }
      if(checkEndOutsideStreak()) return;
    }

    save(); render();
  }

  function clearSelection(){ pushUndo(); S.pendingOutcome = null; save(); render(); }

  function exportCSV(){
    const cols = ["idx","ts","gameNo","series","gameType","outcome","pick","bet","result","delta","gamePnL",
      "mode","modeLosses","phase","ledger","splitPhase","nextSplitBet","ladderBet","consecWinsSame","note"];
    const lines = [cols.join(",")];
    for(const r of S.log){
      const row = cols.map(c=>{
        let v = (r[c] ?? "");
        v = String(v).replaceAll('"','""');
        if(v.includes(",") || v.includes("\n")) v = `"${v}"`;
        return v;
      }).join(",");
      lines.push(row);
    }
    const blob = new Blob([lines.join("\n")], {type:"text/csv;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `APP_session_${S.sessionId}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  function applyBankroll(){
    pushUndo();
    const on = $("bankrollOn").checked;
    S.bankrollOn = on;

    const startStr = $("bankrollStart").value.trim();
    if(startStr.length){
      const n = Number(startStr);
      if(!Number.isFinite(n)){ alert("Starting bankroll must be a number."); return; }
      S.bankrollStart = n;
      S.bankrollCurrent = n;
    } else {
      if(S.bankrollStart == null){
        S.bankrollStart = null;
        S.bankrollCurrent = null;
      }
    }
    save(); render();
  }

  function newEvening(){
    pushUndo();
    const keep = {
      gameType:S.gameType, series:S.series, startMode:S.startMode, autoSeries:S.autoSeries, carryMode:S.carryMode, pendingOneB:S.pendingOneB,
      bankrollOn:S.bankrollOn, bankrollStart:S.bankrollStart, bankrollCurrent:S.bankrollCurrent
    };
    S = defaultState();
    S.sessionId = Date.now();
    Object.assign(S, keep);
    save(); render();
  }

  function resetSession(){
    if(!confirm("Reset session and delete log + undo history?")) return;
    S = defaultState();
    save(); render();
  }

  function renderLog(){
    $("logCount").textContent = String(S.log.length);
    $("gameNo").textContent = String(S.gameNo);

    const body = $("logBody");
    body.innerHTML = "";
    const last = S.log.slice(-250).reverse();
    for(const r of last){
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${r.idx}</td>
        <td>${r.gameNo}</td>
        <td>${r.series}</td>
        <td>${r.gameType}</td>
        <td>${r.outcome}</td>
        <td>${r.pick}</td>
        <td class="right">${r.bet}</td>
        <td>${r.result}</td>
        <td class="right">${r.delta}</td>
        <td class="right">${r.gamePnL}</td>
        <td>${r.mode}</td>
        <td>${r.phase}</td>
        <td class="right">${r.ledger || 0}</td>
        <td>${r.note || ""}</td>
      `;
      body.appendChild(tr);
    }
  }

  function render(){
    $("gameType").value = S.gameType;
    $("series").value = S.series;
    $("startMode").value = S.startMode;
    $("autoSeries").checked = !!S.autoSeries;
    $("carryMode").checked = !!S.carryMode;

    $("bankrollOn").checked = !!S.bankrollOn;
    $("bankrollStart").value = (S.bankrollStart == null) ? "" : String(S.bankrollStart);

    const p = currentParams();

    if(S.bankrollOn && typeof S.bankrollCurrent === "number" && typeof S.bankrollStart === "number"){
      $("bankrollCurrent").textContent = S.bankrollCurrent.toFixed(2);
      $("bankrollNet").textContent = (S.bankrollCurrent - S.bankrollStart).toFixed(2);
    } else {
      $("bankrollCurrent").textContent = "—";
      $("bankrollNet").textContent = "—";
    }

    renderButtons();

    $("selectedOutcome").textContent = S.pendingOutcome ? formatOutcome(S.pendingOutcome) : "—";
    $("submitSelBtn").disabled = !S.pendingOutcome || S.endModalOpen;
    $("clearSelBtn").disabled = !S.pendingOutcome || S.endModalOpen;

    let nextSide = "—";
    let nextBet = "—";
    if(!S.inGame){
      nextSide = "—"; nextBet = "—";
    } else if(!S.observed){
      nextSide = "OBS"; nextBet = "OBS";
    } else {
      const pick = computePick();
      nextSide = formatOutcome(pick);
      if(S.phase === "NORMAL") nextBet = String(S.ladderBet);
      else if(S.phase === "STREAK") nextBet = String(Math.round(S.streakBet));
      else if(S.phase === "SPLIT") nextBet = String(Math.round(S.nextSplitBet || p.min));
    }

    $("nextSide").textContent = nextSide;
    $("nextBet").textContent = nextBet;
    $("mode").textContent = S.inGame ? S.mode : "—";
    $("modeLosses").textContent = S.inGame ? String(S.modeLosses) : "—";
    $("seriesShow").textContent = S.series;
    $("gamePnL").textContent = String(S.gamePnL || 0);
    $("state").textContent = S.phase;
    $("cw").textContent = String(S.consecWinsSame);
    $("ladderBet").textContent = (S.phase === "SPLIT") ? "FROZEN" : (S.ladderBet ? String(S.ladderBet) : "—");
    $("ledger").textContent = (S.phase === "SPLIT") ? String(S.ledger) : "—";
    $("splitPhase").textContent = (S.phase === "SPLIT") ? (S.splitPhase || "—") : "—";
    $("nextSplitBet").textContent = (S.phase === "SPLIT") ? String(Math.round(S.nextSplitBet || p.min)) : "—";

    const hint = [];
    if(S.endModalOpen){
      hint.push("Game ended. Close the popup or start the next game.");
    } else if(!S.inGame){
      hint.push("No active game. Tap New Game, then stage+submit outcomes.");
    } else if(!S.observed){
      hint.push("Observation: stage+submit outcomes until TRUE outcome occurs (R/B or P/B). No bet is placed until then.");
    } else {
      hint.push(`Series ${S.series} TP/SL: ${p.tp} / ${p.sl}.`);
      if(S.phase === "STREAK") hint.push("STREAK: press +base each win; TP ends when streak loses.");
      if(S.phase === "SPLIT") hint.push("SPLIT: probe min → half-pay → remainder; tie push repeats same split bet.");
      if(S.autoSeries && S.pendingOneB) hint.push("Auto Series armed: next game will be Series B (one game).");
    }
    $("hint").textContent = hint.join(" ");

    $("endBackdrop").style.display = S.endModalOpen ? "flex" : "none";
    renderLog();
  }

  // wiring
  $("gameType").addEventListener("change", (e)=>{ pushUndo(); S.gameType = e.target.value; S.pendingOutcome=null; save(); render(); });
  $("series").addEventListener("change", (e)=>{ pushUndo(); S.series = e.target.value; save(); render(); });
  $("startMode").addEventListener("change", (e)=>{ pushUndo(); S.startMode = e.target.value; save(); render(); });

  $("autoSeries").addEventListener("change", (e)=>{ pushUndo(); S.autoSeries = e.target.checked; save(); render(); });
  $("carryMode").addEventListener("change", (e)=>{ pushUndo(); S.carryMode = e.target.checked; save(); render(); });

  $("applyBankrollBtn").addEventListener("click", ()=>applyBankroll());
  $("bankrollOn").addEventListener("change", ()=>applyBankroll());

  $("newGameBtn").addEventListener("click", ()=>startNewGame());
  $("newEveningBtn").addEventListener("click", ()=>newEvening());
  $("resetSessionBtn").addEventListener("click", ()=>resetSession());

  $("exportCsvBtn").addEventListener("click", ()=>exportCSV());

  $("submitSelBtn").addEventListener("click", ()=>submitPending());
  $("clearSelBtn").addEventListener("click", ()=>clearSelection());
  $("undoBtn").addEventListener("click", ()=>undo());

  document.querySelectorAll(".infoBtn").forEach(btn=>{
    btn.addEventListener("click", (e)=>showTip(e.currentTarget.getAttribute("data-tip")));
  });
  $("tipCloseBtn").addEventListener("click", ()=>closeTip());
  $("tipBackdrop").addEventListener("click", (e)=>{ if(e.target.id==="tipBackdrop") closeTip(); });

  $("closeEndBtn").addEventListener("click", ()=>closeEndModal());
  $("nextGameFromModalBtn").addEventListener("click", ()=>{ closeEndModal(); startNewGame(); });
  $("endBackdrop").addEventListener("click", (e)=>{ if(e.target.id==="endBackdrop") closeEndModal(); });

  // init
  save();
  render();
})();
</script>

<!-- Service worker registration (keep at bottom) -->
<script>
  if ("serviceWorker" in navigator) {
    window.addEventListener("load", () => {
      navigator.serviceWorker.register("/service-worker.js");
    });
  }
</script>
</body>
</html>
